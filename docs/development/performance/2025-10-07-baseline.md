# 2025-10-07 Baseline Performance Snapshot

## Bundle metrics

Running `npm run analyze` (Vite analyze mode) generated the following top-level chunks:

| Chunk | Raw Size | Gzip Size | Notes |
|-------|----------|-----------|-------|
| `index-BNMZD3Ql.js` | 491.43 kB | 132.50 kB | Main application bundle containing orchestration-heavy flows; prime target for upcoming decomposition stories. |
| `ui-vendor-CHDmJV_O.js` | 151.77 kB | 46.62 kB | Radix UI and lucide-react aggregation. Manual chunking keeps third-party UI dependencies isolated. |
| `react-vendor-QYCSsVv3.js` | 139.51 kB | 45.14 kB | React/ReactDOM core. Stable anchor chunk used across all builds. |
| `utils-CBw3aSZY.js` | 82.62 kB | 23.34 kB | Shared utilities (Autosave, file providers, reporting). Review for tree-shake candidates before adding new helpers. |
| `index-CgAMJNMK.css` | 136.17 kB | 20.93 kB | Tailwind global layer. Track for regression if additional design tokens expand the sheet. |
| Modal chunks (`NoteModal`, `FinancialItemModal`, `ConnectToExistingModal`) | 2–9 kB | 1–3 kB | Lazy-loaded dialogs remain lightweight; no action required yet. |

The generated treemap was archived at `docs/development/performance/2025-10-07-bundle-analysis.html` for diffable tracking.

## Runtime instrumentation outputs

- `useNavigationFlow` emits timing samples for guard checks, view transitions, and list/detail mutations through `performanceTracker`.
- `AppContent` is wrapped in a React `Profiler` that records mount/update durations plus context metadata (view, case count, lock state).
- `npm run perf:baseline` runs `scripts/performanceBaseline.ts`, which primes the instrumentation under a JSDOM-friendly `performance` implementation and writes raw samples to `docs/development/performance/2025-10-07-performance-log.json`.

### Baseline sample (`perf:baseline`)

| Metric | Value | Detail |
|--------|-------|--------|
| Navigation sample (`navigation:backToDashboard`) | 19.01 ms duration | Start/end captured around a simulated dashboard return; metadata annotated with `{ scenario: "baseline" }`. |
| AppContent mount render | 22.34 ms actual / 16.34 ms base | Recorded via `recordRenderProfile`; confirms Profiler wiring emits structured metadata for downstream analysis. |

The JSON log also captures the raw `performance.now()` timestamps, making it easy to diff future baseline runs.

### Accessing samples during local runs

```ts
import { getRecordedMeasurements, getRenderProfiles } from "@/utils/performanceTracker";

console.table(getRecordedMeasurements());
console.table(getRenderProfiles());
```

In the browser, import the helpers on demand with `await import("/utils/performanceTracker")` while the Vite dev server is running.

## Immediate observations

- Main bundle remains ~491 kB raw / 133 kB gzip. Splitting orchestration out of `App.tsx` into feature-specific entry points should be the first optimization story.
- `utils-*` is the largest non-core chunk; start by auditing Autosave/File storage exports for code that can move behind dynamic imports.
- Navigation timings are already captured—monitor future runs for spikes when filesystem prompts appear or large case lists load.

## Suggested follow-ups

1. Capture a real interaction trace (dashboard → list → case detail) during a dev session and archive the resulting `getRecordedMeasurements()` + `getRenderProfiles()` output alongside the treemap.
2. Use React DevTools Profiler to validate that AppContent commit durations in real sessions match the logged samples; prioritize memoization work if updates routinely exceed ~25 ms.
3. Inspect `utils-CBw3aSZY.js` within the treemap to identify candidates for further manual chunking (e.g., Autosave services vs. reporting utilities).
